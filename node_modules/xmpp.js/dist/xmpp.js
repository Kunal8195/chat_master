(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.xmpp = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

},{}],2:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;

  if (!this._events) this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++) {
      listeners[i].apply(this, args);
    }
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events || !this._events[type]) return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;

  if (!this._events) return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) {
      this.removeListener(type, listeners[listeners.length - 1]);
    }
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],3:[function(require,module,exports){
'use strict';

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],4:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var escape = require('./escape');
var escapeXML = escape.escapeXML;
var escapeXMLText = escape.escapeXMLText;

var equality = require('./equal');
var equal = equality.equal;
var nameEqual = equality.name;
var attrsEqual = equality.attrs;
var childrenEqual = equality.children;

var clone = require('./clone');

/**
 * Element
 *
 * Attributes are in the element.attrs object. Children is a list of
 * either other Elements or Strings for text content.
 **/
function Element(name, attrs) {
  this.name = name;
  this.parent = null;
  this.children = [];
  this.attrs = {};
  this.setAttrs(attrs);
}

/* Accessors */

/**
 * if (element.is('message', 'jabber:client')) ...
 **/
Element.prototype.is = function (name, xmlns) {
  return this.getName() === name && (!xmlns || this.getNS() === xmlns);
};

/* without prefix */
Element.prototype.getName = function () {
  if (this.name.indexOf(':') >= 0) {
    return this.name.substr(this.name.indexOf(':') + 1);
  } else {
    return this.name;
  }
};

/**
 * retrieves the namespace of the current element, upwards recursively
 **/
Element.prototype.getNS = function () {
  if (this.name.indexOf(':') >= 0) {
    var prefix = this.name.substr(0, this.name.indexOf(':'));
    return this.findNS(prefix);
  }
  return this.findNS();
};

/**
 * find the namespace to the given prefix, upwards recursively
 **/
Element.prototype.findNS = function (prefix) {
  if (!prefix) {
    /* default namespace */
    if (this.attrs.xmlns) {
      return this.attrs.xmlns;
    } else if (this.parent) {
      return this.parent.findNS();
    }
  } else {
    /* prefixed namespace */
    var attr = 'xmlns:' + prefix;
    if (this.attrs[attr]) {
      return this.attrs[attr];
    } else if (this.parent) {
      return this.parent.findNS(prefix);
    }
  }
};

/**
 * Recursiverly gets all xmlns defined, in the form of {url:prefix}
 **/
Element.prototype.getXmlns = function () {
  var namespaces = {};

  if (this.parent) {
    namespaces = this.parent.getXmlns();
  }

  for (var attr in this.attrs) {
    var m = attr.match('xmlns:?(.*)');
    if (this.attrs.hasOwnProperty(attr) && m) {
      namespaces[this.attrs[attr]] = m[1];
    }
  }
  return namespaces;
};

Element.prototype.setAttrs = function (attrs) {
  if (typeof attrs === 'string') {
    this.attrs.xmlns = attrs;
  } else if (attrs) {
    Object.keys(attrs).forEach(function (key) {
      this.attrs[key] = attrs[key];
    }, this);
  }
};

/**
 * xmlns can be null, returns the matching attribute.
 **/
Element.prototype.getAttr = function (name, xmlns) {
  if (!xmlns) {
    return this.attrs[name];
  }

  var namespaces = this.getXmlns();

  if (!namespaces[xmlns]) {
    return null;
  }

  return this.attrs[[namespaces[xmlns], name].join(':')];
};

/**
 * xmlns can be null
 **/
Element.prototype.getChild = function (name, xmlns) {
  return this.getChildren(name, xmlns)[0];
};

/**
 * xmlns can be null
 **/
Element.prototype.getChildren = function (name, xmlns) {
  var result = [];
  for (var i = 0; i < this.children.length; i++) {
    var child = this.children[i];
    if (child.getName && child.getName() === name && (!xmlns || child.getNS() === xmlns)) {
      result.push(child);
    }
  }
  return result;
};

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildByAttr = function (attr, val, xmlns, recursive) {
  return this.getChildrenByAttr(attr, val, xmlns, recursive)[0];
};

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildrenByAttr = function (attr, val, xmlns, recursive) {
  var result = [];
  for (var i = 0; i < this.children.length; i++) {
    var child = this.children[i];
    if (child.attrs && child.attrs[attr] === val && (!xmlns || child.getNS() === xmlns)) {
      result.push(child);
    }
    if (recursive && child.getChildrenByAttr) {
      result.push(child.getChildrenByAttr(attr, val, xmlns, true));
    }
  }
  if (recursive) {
    result = [].concat.apply([], result);
  }
  return result;
};

Element.prototype.getChildrenByFilter = function (filter, recursive) {
  var result = [];
  for (var i = 0; i < this.children.length; i++) {
    var child = this.children[i];
    if (filter(child)) {
      result.push(child);
    }
    if (recursive && child.getChildrenByFilter) {
      result.push(child.getChildrenByFilter(filter, true));
    }
  }
  if (recursive) {
    result = [].concat.apply([], result);
  }
  return result;
};

Element.prototype.getText = function () {
  var text = '';
  for (var i = 0; i < this.children.length; i++) {
    var child = this.children[i];
    if (typeof child === 'string' || typeof child === 'number') {
      text += child;
    }
  }
  return text;
};

Element.prototype.getChildText = function (name, xmlns) {
  var child = this.getChild(name, xmlns);
  return child ? child.getText() : null;
};

/**
 * Return all direct descendents that are Elements.
 * This differs from `getChildren` in that it will exclude text nodes,
 * processing instructions, etc.
 */
Element.prototype.getChildElements = function () {
  return this.getChildrenByFilter(function (child) {
    return child instanceof Element;
  });
};

/* Builder */

/** returns uppermost parent */
Element.prototype.root = function () {
  if (this.parent) {
    return this.parent.root();
  }
  return this;
};
Element.prototype.tree = Element.prototype.root;

/** just parent or itself */
Element.prototype.up = function () {
  if (this.parent) {
    return this.parent;
  }
  return this;
};

/** create child node and return it */
Element.prototype.c = function (name, attrs) {
  return this.cnode(new Element(name, attrs));
};

Element.prototype.cnode = function (child) {
  this.children.push(child);
  if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) === 'object') {
    child.parent = this;
  }
  return child;
};

/** add text node and return element */
Element.prototype.t = function (text) {
  this.children.push(text);
  return this;
};

/* Manipulation */

/**
 * Either:
 *   el.remove(childEl)
 *   el.remove('author', 'urn:...')
 */
Element.prototype.remove = function (el, xmlns) {
  var filter;
  if (typeof el === 'string') {
    /* 1st parameter is tag name */
    filter = function filter(child) {
      return !(child.is && child.is(el, xmlns));
    };
  } else {
    /* 1st parameter is element */
    filter = function filter(child) {
      return child !== el;
    };
  }

  this.children = this.children.filter(filter);

  return this;
};

Element.prototype.clone = function () {
  return clone(this);
};

Element.prototype.text = function (val) {
  if (val && this.children.length === 1) {
    this.children[0] = val;
    return this;
  }
  return this.getText();
};

Element.prototype.attr = function (attr, val) {
  if (typeof val !== 'undefined' || val === null) {
    if (!this.attrs) {
      this.attrs = {};
    }
    this.attrs[attr] = val;
    return this;
  }
  return this.attrs[attr];
};

/* Serialization */

Element.prototype.toString = function () {
  var s = '';
  this.write(function (c) {
    s += c;
  });
  return s;
};

Element.prototype.toJSON = function () {
  return {
    name: this.name,
    attrs: this.attrs,
    children: this.children.map(function (child) {
      return child && child.toJSON ? child.toJSON() : child;
    })
  };
};

Element.prototype._addChildren = function (writer) {
  writer('>');
  for (var i = 0; i < this.children.length; i++) {
    var child = this.children[i];
    /* Skip null/undefined */
    if (child || child === 0) {
      if (child.write) {
        child.write(writer);
      } else if (typeof child === 'string') {
        writer(escapeXMLText(child));
      } else if (child.toString) {
        writer(escapeXMLText(child.toString(10)));
      }
    }
  }
  writer('</');
  writer(this.name);
  writer('>');
};

Element.prototype.write = function (writer) {
  writer('<');
  writer(this.name);
  for (var k in this.attrs) {
    var v = this.attrs[k];
    if (v != null) {
      // === null || undefined
      writer(' ');
      writer(k);
      writer('="');
      if (typeof v !== 'string') {
        v = v.toString();
      }
      writer(escapeXML(v));
      writer('"');
    }
  }
  if (this.children.length === 0) {
    writer('/>');
  } else {
    this._addChildren(writer);
  }
};

Element.prototype.nameEquals = function (el) {
  return nameEqual(this, el);
};

Element.prototype.attrsEquals = function (el) {
  return attrsEqual(this, el);
};

Element.prototype.childrenEquals = function (el) {
  return childrenEqual(this, el);
};

Element.prototype.equals = function (el) {
  return equal(this, el);
};

module.exports = Element;

},{"./clone":5,"./equal":6,"./escape":7}],5:[function(require,module,exports){
'use strict';

module.exports = function clone(el) {
  var clone = new el.constructor(el.name, el.attrs);
  for (var i = 0; i < el.children.length; i++) {
    var child = el.children[i];
    clone.cnode(child.clone ? child.clone() : child);
  }
  return clone;
};

},{}],6:[function(require,module,exports){
'use strict';

function nameEqual(a, b) {
  return a.name === b.name;
}

function attrsEqual(a, b) {
  var attrs = a.attrs;
  var keys = Object.keys(attrs);
  var length = keys.length;
  if (length !== Object.keys(b.attrs).length) return false;
  for (var i = 0, l = length; i < l; i++) {
    var key = keys[i];
    var value = attrs[key];
    if (value == null || b.attrs[key] == null) {
      // === null || undefined
      if (value !== b.attrs[key]) return false;
    } else if (value.toString() !== b.attrs[key].toString()) {
      return false;
    }
  }
  return true;
}

function childrenEqual(a, b) {
  var children = a.children;
  var length = children.length;
  if (length !== b.children.length) return false;
  for (var i = 0, l = length; i < l; i++) {
    var child = children[i];
    if (typeof child === 'string') {
      if (child !== b.children[i]) return false;
    } else {
      if (!child.equals(b.children[i])) return false;
    }
  }
  return true;
}

function equal(a, b) {
  if (!nameEqual(a, b)) return false;
  if (!attrsEqual(a, b)) return false;
  if (!childrenEqual(a, b)) return false;
  return true;
}

module.exports.name = nameEqual;
module.exports.attrs = attrsEqual;
module.exports.children = childrenEqual;
module.exports.equal = equal;

},{}],7:[function(require,module,exports){
'use strict';

var escapeXMLTable = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  '\'': '&apos;'
};

function escapeXMLReplace(match) {
  return escapeXMLTable[match];
}

var unescapeXMLTable = {
  '&amp;': '&',
  '&#38;': '&',
  '&lt;': '<',
  '&#60;': '<',
  '&gt;': '>',
  '&#62;': '>',
  '&quot;': '"',
  '&#34;': '"',
  '&apos;': "'",
  '&#39;': "'"
};

function unescapeXMLReplace(match) {
  return unescapeXMLTable[match];
}

exports.escapeXML = function escapeXML(s) {
  return s.replace(/&|<|>|"|'/g, escapeXMLReplace);
};

exports.unescapeXML = function unescapeXML(s) {
  return s.replace(/&(amp|#38|lt|#60|gt|#62|quot|#34|apos|#39);/g, unescapeXMLReplace);
};

exports.escapeXMLText = function escapeXMLText(s) {
  return s.replace(/&|<|>/g, escapeXMLReplace);
};

exports.unescapeXMLText = function unescapeXMLText(s) {
  return s.replace(/&(amp|#38|lt|#60|gt|#62);/g, unescapeXMLReplace);
};

},{}],8:[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var EventEmitter = require('events').EventEmitter;
var unescapeXML = require('../escape').unescapeXML;

var STATE_TEXT = 0;
var STATE_IGNORE_COMMENT = 1;
var STATE_IGNORE_INSTRUCTION = 2;
var STATE_TAG_NAME = 3;
var STATE_TAG = 4;
var STATE_ATTR_NAME = 5;
var STATE_ATTR_EQ = 6;
var STATE_ATTR_QUOT = 7;
var STATE_ATTR_VALUE = 8;
var STATE_CDATA = 9;

var SaxLtx = module.exports = function SaxLtx() {
  EventEmitter.call(this);

  var state = STATE_TEXT;
  var remainder;
  var tagName;
  var attrs;
  var endTag;
  var selfClosing;
  var attrQuote;
  var recordStart = 0;
  var attrName;

  this._handleTagOpening = function (endTag, tagName, attrs) {
    if (!endTag) {
      this.emit('startElement', tagName, attrs);
      if (selfClosing) {
        this.emit('endElement', tagName);
      }
    } else {
      this.emit('endElement', tagName);
    }
  };

  this.write = function (data) {
    if (typeof data !== 'string') {
      data = data.toString();
    }
    var pos = 0;

    /* Anything from previous write()? */
    if (remainder) {
      data = remainder + data;
      pos += remainder.length;
      remainder = null;
    }

    function endRecording() {
      if (typeof recordStart === 'number') {
        var recorded = data.slice(recordStart, pos);
        recordStart = undefined;
        return recorded;
      }
    }

    for (; pos < data.length; pos++) {
      var c = data.charCodeAt(pos);
      switch (state) {
        case STATE_TEXT:
          if (c === 60 /* < */) {
              var text = endRecording();
              if (text) {
                this.emit('text', unescapeXML(text));
              }
              state = STATE_TAG_NAME;
              recordStart = pos + 1;
              attrs = {};
            }
          break;
        case STATE_CDATA:
          if (c === 93 /* ] */ && data.substr(pos + 1, 2) === ']>') {
            var cData = endRecording();
            if (cData) {
              this.emit('text', cData);
            }
            state = STATE_IGNORE_COMMENT;
          }
          break;
        case STATE_TAG_NAME:
          if (c === 47 /* / */ && recordStart === pos) {
            recordStart = pos + 1;
            endTag = true;
          } else if (c === 33 /* ! */) {
              if (data.substr(pos + 1, 7) === '[CDATA[') {
                recordStart = pos + 8;
                state = STATE_CDATA;
              } else {
                recordStart = undefined;
                state = STATE_IGNORE_COMMENT;
              }
            } else if (c === 63 /* ? */) {
              recordStart = undefined;
              state = STATE_IGNORE_INSTRUCTION;
            } else if (c <= 32 || c === 47 /* / */ || c === 62 /* > */) {
              tagName = endRecording();
              pos--;
              state = STATE_TAG;
            }
          break;
        case STATE_IGNORE_COMMENT:
          if (c === 62 /* > */) {
              var prevFirst = data.charCodeAt(pos - 1);
              var prevSecond = data.charCodeAt(pos - 2);
              if (prevFirst === 45 /* - */ && prevSecond === 45 /* - */ || prevFirst === 93 /* ] */ && prevSecond === 93 /* ] */) {
                state = STATE_TEXT;
              }
            }
          break;
        case STATE_IGNORE_INSTRUCTION:
          if (c === 62 /* > */) {
              var prev = data.charCodeAt(pos - 1);
              if (prev === 63 /* ? */) {
                  state = STATE_TEXT;
                }
            }
          break;
        case STATE_TAG:
          if (c === 62 /* > */) {
              this._handleTagOpening(endTag, tagName, attrs);
              tagName = undefined;
              attrs = undefined;
              endTag = undefined;
              selfClosing = undefined;
              state = STATE_TEXT;
              recordStart = pos + 1;
            } else if (c === 47 /* / */) {
              selfClosing = true;
            } else if (c > 32) {
            recordStart = pos;
            state = STATE_ATTR_NAME;
          }
          break;
        case STATE_ATTR_NAME:
          if (c <= 32 || c === 61 /* = */) {
              attrName = endRecording();
              pos--;
              state = STATE_ATTR_EQ;
            }
          break;
        case STATE_ATTR_EQ:
          if (c === 61 /* = */) {
              state = STATE_ATTR_QUOT;
            }
          break;
        case STATE_ATTR_QUOT:
          if (c === 34 /* " */ || c === 39 /* ' */) {
              attrQuote = c;
              state = STATE_ATTR_VALUE;
              recordStart = pos + 1;
            }
          break;
        case STATE_ATTR_VALUE:
          if (c === attrQuote) {
            var value = unescapeXML(endRecording());
            attrs[attrName] = value;
            attrName = undefined;
            state = STATE_TAG;
          }
          break;
      }
    }

    if (typeof recordStart === 'number' && recordStart <= data.length) {
      remainder = data.slice(recordStart);
      recordStart = 0;
    }
  };
  /*
  var origEmit = this.emit
  this.emit = function() {
    console.log('ltx', arguments)
    origEmit.apply(this, arguments)
  }
  */
};
inherits(SaxLtx, EventEmitter);

SaxLtx.prototype.end = function (data) {
  if (data) {
    this.write(data);
  }

  /* Uh, yeah */
  this.write = function () {};
};

},{"../escape":7,"events":2,"inherits":3}],9:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (root, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
})(undefined, function (exports, module) {

  /**
   * ANONYMOUS `Mechanism` constructor.
   *
   * This class implements the ANONYMOUS SASL mechanism.
   *
   * The ANONYMOUS SASL mechanism provides support for permitting anonymous
   * access to various services
   *
   * References:
   *  - [RFC 4505](http://tools.ietf.org/html/rfc4505)
   *
   * @api public
   */
  function Mechanism() {}

  Mechanism.prototype.name = 'ANONYMOUS';
  Mechanism.prototype.clientFirst = true;

  /**
   * Encode a response using optional trace information.
   *
   * Options:
   *  - `trace`  trace information (optional)
   *
   * @param {Object} cred
   * @api public
   */
  Mechanism.prototype.response = function (cred) {
    return cred.trace || '';
  };

  /**
   * Decode a challenge issued by the server.
   *
   * @param {String} chal
   * @api public
   */
  Mechanism.prototype.challenge = function (chal) {};

  exports = module.exports = Mechanism;
});

},{}],10:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (root, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    // CommonJS
    factory(exports, module, require('./lib/mechanism'));
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module', './lib/mechanism'], factory);
  }
})(undefined, function (exports, module, Mechanism) {

  exports = module.exports = Mechanism;
  exports.Mechanism = Mechanism;
});

},{"./lib/mechanism":9}],11:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (root, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
})(undefined, function (exports, module) {

  /**
   * PLAIN `Mechanism` constructor.
   *
   * This class implements the PLAIN SASL mechanism.
   *
   * The PLAIN SASL mechanism provides support for exchanging a clear-text
   * username and password.  This mechanism should not be used without adequate
   * security provided by an underlying transport layer. 
   *
   * References:
   *  - [RFC 4616](http://tools.ietf.org/html/rfc4616)
   *
   * @api public
   */
  function Mechanism() {}

  Mechanism.prototype.name = 'PLAIN';
  Mechanism.prototype.clientFirst = true;

  /**
   * Encode a response using given credential.
   *
   * Options:
   *  - `username`
   *  - `password`
   *  - `authzid`   authorization identity (optional)
   *
   * @param {Object} cred
   * @api public
   */
  Mechanism.prototype.response = function (cred) {
    var str = '';
    str += cred.authzid || '';
    str += '\0';
    str += cred.username;
    str += '\0';
    str += cred.password;
    return str;
  };

  /**
   * Decode a challenge issued by the server.
   *
   * @param {String} chal
   * @return {Mechanism} for chaining
   * @api public
   */
  Mechanism.prototype.challenge = function (chal) {
    return this;
  };

  exports = module.exports = Mechanism;
});

},{}],12:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"./lib/mechanism":11,"dup":10}],13:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (root, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
})(undefined, function (exports, module) {

  /**
   * `Factory` constructor.
   *
   * @api public
   */
  function Factory() {
    this._mechs = [];
  }

  /**
   * Utilize the given `mech` with optional `name`, overridding the mechanism's
   * default name.
   *
   * Examples:
   *
   *     factory.use(FooMechanism);
   *
   *     factory.use('XFOO', FooMechanism);
   *
   * @param {String|Mechanism} name
   * @param {Mechanism} mech
   * @return {Factory} for chaining
   * @api public
   */
  Factory.prototype.use = function (name, mech) {
    if (!mech) {
      mech = name;
      name = mech.prototype.name;
    }
    this._mechs.push({ name: name, mech: mech });
    return this;
  };

  /**
   * Create a new mechanism from supported list of `mechs`.
   *
   * If no mechanisms are supported, returns `null`.
   *
   * Examples:
   *
   *     var mech = factory.create(['FOO', 'BAR']);
   *
   * @param {Array} mechs
   * @return {Mechanism}
   * @api public
   */
  Factory.prototype.create = function (mechs) {
    for (var i = 0, len = this._mechs.length; i < len; i++) {
      for (var j = 0, jlen = mechs.length; j < jlen; j++) {
        var entry = this._mechs[i];
        if (entry.name == mechs[j]) {
          return new entry.mech();
        }
      }
    }
    return null;
  };

  exports = module.exports = Factory;
});

},{}],14:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (root, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
    // CommonJS
    factory(exports, module, require('./lib/factory'));
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module', './lib/factory'], factory);
  }
})(undefined, function (exports, module, Factory) {

  exports = module.exports = Factory;
  exports.Factory = Factory;
});

},{"./lib/factory":13}],15:[function(require,module,exports){
'use strict';

var Client = require('./lib/Client');
var xml = require('@xmpp/xml');
var jid = require('@xmpp/jid');

module.exports.Client = Client;
module.exports.xml = xml;
module.exports.jid = jid;

},{"./lib/Client":16,"@xmpp/jid":24,"@xmpp/xml":43}],16:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Connection = require('@xmpp/connection');

var Client = function (_Connection) {
  _inherits(Client, _Connection);

  function Client(options) {
    _classCallCheck(this, Client);

    var _this = _possibleConstructorReturn(this, (Client.__proto__ || Object.getPrototypeOf(Client)).call(this, options));

    _this.transports = [];
    return _this;
  }

  _createClass(Client, [{
    key: 'send',
    value: function send(element) {
      var _get2;

      if (!element.attrs.xmlns && (element.is('iq') || element.is('message') || element.is('presence'))) {
        element.attrs.xmlns = 'jabber:client'; // FIXME no need for TCP/TLS transports
      }

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_get2 = _get(Client.prototype.__proto__ || Object.getPrototypeOf(Client.prototype), 'send', this)).call.apply(_get2, [this, element].concat(args));
    }
  }, {
    key: 'connect',
    value: function connect(uri) {
      var Transport = this.transports.find(function (Transport) {
        try {
          return Transport.prototype.socketParameters(uri) !== undefined;
        } catch (err) {
          return false;
        }
      });

      if (!Transport) {
        throw new Error('No compatible connection method found.');
      }

      this.Transport = Transport;
      this.Socket = Transport.prototype.Socket;
      this.Parser = Transport.prototype.Parser;

      return _get(Client.prototype.__proto__ || Object.getPrototypeOf(Client.prototype), 'connect', this).call(this, uri);
    }
  }, {
    key: 'socketParameters',
    value: function socketParameters() {
      var _Transport$prototype;

      return (_Transport$prototype = this.Transport.prototype).socketParameters.apply(_Transport$prototype, arguments);
    }
  }, {
    key: 'header',
    value: function header() {
      var _Transport$prototype2;

      return (_Transport$prototype2 = this.Transport.prototype).header.apply(_Transport$prototype2, arguments);
    }
  }, {
    key: 'headerElement',
    value: function headerElement() {
      var _Transport$prototype3;

      return (_Transport$prototype3 = this.Transport.prototype).headerElement.apply(_Transport$prototype3, arguments);
    }
  }, {
    key: 'footer',
    value: function footer() {
      var _Transport$prototype4;

      return (_Transport$prototype4 = this.Transport.prototype).footer.apply(_Transport$prototype4, arguments);
    }
  }, {
    key: 'footerElement',
    value: function footerElement() {
      var _Transport$prototype5;

      return (_Transport$prototype5 = this.Transport.prototype).footerElement.apply(_Transport$prototype5, arguments);
    }
  }]);

  return Client;
}(Connection);

Client.prototype.NS = 'jabber:client';

module.exports = Client;

},{"@xmpp/connection":17}],17:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require = require('@xmpp/events'),
    timeout = _require.timeout,
    EventEmitter = _require.EventEmitter,
    promise = _require.promise;

var jid = require('@xmpp/jid');
var url = require('url');
var xml = require('@xmpp/xml');

var XMPPError = function (_Error) {
  _inherits(XMPPError, _Error);

  function XMPPError(condition, text, element) {
    _classCallCheck(this, XMPPError);

    var _this = _possibleConstructorReturn(this, (XMPPError.__proto__ || Object.getPrototypeOf(XMPPError)).call(this, condition + (text ? ' - ' + text : '')));

    _this.name = 'XMPPError';
    _this.condition = condition;
    _this.text = text;
    _this.element = element;
    return _this;
  }

  return XMPPError;
}(Error);

var StreamError = function (_XMPPError) {
  _inherits(StreamError, _XMPPError);

  function StreamError() {
    var _ref;

    _classCallCheck(this, StreamError);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this2 = _possibleConstructorReturn(this, (_ref = StreamError.__proto__ || Object.getPrototypeOf(StreamError)).call.apply(_ref, [this].concat(args)));

    _this2.name = 'StreamError';
    return _this2;
  }

  return StreamError;
}(XMPPError);

// We ignore url module from the browser bundle to reduce its size


function getHostname(uri) {
  if (url.parse) {
    var parsed = url.parse(uri);
    return parsed.hostname || parsed.pathname;
  }
  var el = document.createElement('a'); // eslint-disable-line no-undef
  el.href = uri;
  return el.hostname;
}

var Connection = function (_EventEmitter) {
  _inherits(Connection, _EventEmitter);

  function Connection(options) {
    _classCallCheck(this, Connection);

    var _this3 = _possibleConstructorReturn(this, (Connection.__proto__ || Object.getPrototypeOf(Connection)).call(this));

    _this3.domain = '';
    _this3.lang = '';
    _this3.jid = null;
    _this3.timeout = 2000;
    _this3.options = (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' ? options : {};
    _this3.plugins = Object.create(null);
    _this3.startOptions = null;
    _this3.openOptions = null;
    _this3.connectOptions = null;
    _this3.socketListeners = Object.create(null);
    _this3.parserListeners = Object.create(null);
    _this3.status = 'offline';
    return _this3;
  }

  _createClass(Connection, [{
    key: '_reset',
    value: function _reset() {
      this.domain = '';
      this.lang = '';
      this.jid = null;
      this._detachSocket();
      this._detachParser();
      this.socket = null;
    }
  }, {
    key: '_attachSocket',
    value: function _attachSocket(socket) {
      var _this4 = this;

      var sock = this.socket = socket;
      var listeners = this.socketListeners;
      listeners.data = function (data) {
        var str = data.toString('utf8');
        _this4.emit('input', str);
        _this4.parser.write(str);
      };
      listeners.close = function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this4._reset();
        _this4._status.apply(_this4, ['disconnect'].concat(args));
      };
      listeners.connect = function () {
        _this4._status('connect');
        sock.once('close', listeners.close);
      };
      listeners.error = function (error) {
        _this4._reset();
        if (_this4.status === 'connecting') {
          _this4._status('offline');
        }
        _this4.emit('error', error);
      };
      sock.on('data', listeners.data);
      sock.on('error', listeners.error);
      sock.on('connect', listeners.connect);
    }
  }, {
    key: '_detachSocket',
    value: function _detachSocket() {
      var _this5 = this;

      var listeners = this.socketListeners;
      Object.getOwnPropertyNames(listeners).forEach(function (k) {
        _this5.socket.removeListener(k, listeners[k]);
        delete listeners[k];
      });
      delete this.socket;
    }
  }, {
    key: '_attachParser',
    value: function _attachParser(p) {
      var _this6 = this;

      var parser = this.parser = p;
      var listeners = this.parserListeners;
      listeners.element = function (element) {
        if (element.name === 'stream:error') {
          _this6.close().then(function () {
            return _this6.disconnect();
          });
          _this6.emit('error', new StreamError(element.children[0].name, element.getChildText('text', 'urn:ietf:params:xml:ns:xmpp-streams') || '', element));
        }
        _this6.emit('element', element);
        _this6.emit(_this6.isStanza(element) ? 'stanza' : 'nonza', element);
      };
      listeners.error = function (error) {
        _this6.emit('error', error);
      };
      listeners.end = function (element) {
        _this6._status('close', element);
      };
      parser.once('error', listeners.error);
      parser.on('element', listeners.element);
      parser.on('end', listeners.end);
    }
  }, {
    key: '_detachParser',
    value: function _detachParser() {
      var _this7 = this;

      var listeners = this.parserListeners;
      Object.getOwnPropertyNames(listeners).forEach(function (k) {
        _this7.parser.removeListener(k, listeners[k]);
        delete listeners[k];
      });
      delete this.parser;
    }
  }, {
    key: '_jid',
    value: function _jid(id) {
      this.jid = jid(id);
      return this.jid;
    }
  }, {
    key: '_status',
    value: function _status(status) {
      this.status = status;

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      this.emit.apply(this, ['status', status].concat(args));
      this.emit.apply(this, [status].concat(args));
    }

    /**
     * Opens the socket then opens the stream
     */

  }, {
    key: 'start',
    value: function start(options) {
      var _this8 = this;

      if (this.status !== 'offline') {
        return Promise.reject(new Error('Connection is not offline'));
      }

      this.startOptions = options;

      if (typeof options === 'string') {
        options = { uri: options };
      }

      if (!options.domain) {
        options.domain = getHostname(options.uri);
      }

      return Promise.all([this.promise('online'), this.connect(options.uri).then(function () {
        var _options = options,
            domain = _options.domain,
            lang = _options.lang;

        return _this8.open({ domain: domain, lang: lang });
      })]).then(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 1),
            addr = _ref3[0];

        return addr;
      });
    }

    /**
     * Connects the socket
     */

  }, {
    key: 'connect',
    value: function connect(options) {
      var _this9 = this;

      this._status('connecting');
      this.connectOptions = options;
      return new Promise(function (resolve, reject) {
        _this9._attachParser(new _this9.Parser());
        _this9._attachSocket(new _this9.Socket());
        _this9.socket.once('error', reject);
        _this9.socket.connect(_this9.socketParameters(options), function () {
          _this9.socket.removeListener('error', reject);
          resolve();
          // The 'connect' status is emitted by the socket 'connect' listener
        });
      });
    }

    /**
     * Disconnects the socket
     * https://xmpp.org/rfcs/rfc6120.html#streams-close
     * https://tools.ietf.org/html/rfc7395#section-3.6
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      var ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;

      this._status('disconnecting');
      this.socket.end();
      return timeout(promise(this.socket, 'close'), ms);
      // The 'disconnect' status is emitted by the socket 'close' listener
    }

    /**
     * Opens the stream
     */

  }, {
    key: 'open',
    value: function open(options) {
      var _this10 = this;

      this._status('opening');
      // Useful for stream-features restart
      this.openOptions = options;
      if (typeof options === 'string') {
        options = { domain: options };
      }

      var _options2 = options,
          domain = _options2.domain,
          lang = _options2.lang;


      var headerElement = this.headerElement();
      headerElement.attrs.to = domain;
      headerElement.attrs['xml:lang'] = lang;

      return Promise.all([this.write(this.header(headerElement)), promise(this.parser, 'start').then(function (el) {
        // FIXME what about version and xmlns:stream ?
        if (el.name !== headerElement.name || el.attrs.xmlns !== headerElement.attrs.xmlns || el.attrs.from !== headerElement.attrs.to || !el.attrs.id) {
          return _this10.promise('error');
        }

        _this10.domain = domain;
        _this10.lang = el.attrs['xml:lang'];
        _this10._status('open', el);
        return el;
      })]).then(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
            el = _ref5[1];

        return el;
      });
    }

    /**
     * Closes the stream then closes the socket
     * https://xmpp.org/rfcs/rfc6120.html#streams-close
     * https://tools.ietf.org/html/rfc7395#section-3.6
     */

  }, {
    key: 'stop',
    value: function stop() {
      var _this11 = this;

      if (!this.socket) {
        return Promise.resolve();
      }
      return this.close().then(function (el) {
        return _this11.disconnect().then(function () {
          _this11._status('offline');
          return el;
        });
      });
    }

    /**
     * Closes the stream and wait for the server to close it
     * https://xmpp.org/rfcs/rfc6120.html#streams-close
     * https://tools.ietf.org/html/rfc7395#section-3.6
     */

  }, {
    key: 'close',
    value: function close() {
      var ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;

      this._status('closing');

      return Promise.all([timeout(promise(this.parser, 'end'), ms), this.write(this.footer(this.footerElement()))]).then(function (_ref6) {
        var _ref7 = _slicedToArray(_ref6, 1),
            el = _ref7[0];

        return el;
      });
      // The 'close' status is emitted by the parser 'end' listener
    }

    /**
     * Restart the stream
     * https://xmpp.org/rfcs/rfc6120.html#streams-negotiation-restart
     */

  }, {
    key: 'restart',
    value: function restart() {
      var _this12 = this;

      this._detachParser();
      this._attachParser(new this.Parser());
      this._status('restarting');
      return this.open(this.openOptions).then(function () {
        _this12._status('restart');
      });
    }
  }, {
    key: 'send',
    value: function send(element) {
      var _this13 = this;

      return this.write(element).then(function () {
        _this13.emit('send', element);
      });
    }
  }, {
    key: 'sendReceive',
    value: function sendReceive(element) {
      var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;

      return Promise.all([this.send(element), timeout(this.promise('element'), ms)]).then(function (_ref8) {
        var _ref9 = _slicedToArray(_ref8, 2),
            el = _ref9[1];

        return el;
      });
    }
  }, {
    key: 'write',
    value: function write(data) {
      var _this14 = this;

      return new Promise(function (resolve, reject) {
        var str = data.toString('utf8');
        _this14.socket.write(str, function (err) {
          if (err) {
            return reject(err);
          }
          _this14.emit('output', str);
          resolve();
        });
      });
    }
  }, {
    key: 'isStanza',
    value: function isStanza(element) {
      var name = element.name;

      var NS = element.attrs.xmlns;
      return (
        // This.online && FIXME
        (NS ? NS === this.NS : true) && (name === 'iq' || name === 'message' || name === 'presence')
      );
    }
  }, {
    key: 'isNonza',
    value: function isNonza(element) {
      return !this.isStanza(element);
    }
  }, {
    key: 'plugin',
    value: function plugin(_plugin) {
      if (!this.plugins[_plugin.name]) {
        this.plugins[_plugin.name] = _plugin.plugin(this);
        var p = this.plugins[_plugin.name];
        if (p && p.start) {
          p.start();
        } else if (p && p.register) {
          p.register();
        }
      }

      return this.plugins[_plugin.name];
    }

    // Override

  }, {
    key: 'header',
    value: function header(el) {
      return el.toString();
    }
  }, {
    key: 'headerElement',
    value: function headerElement() {
      return new xml.Element('', {
        version: '1.0',
        xmlns: this.NS
      });
    }
  }, {
    key: 'footer',
    value: function footer(el) {
      return el.toString();
    }
  }, {
    key: 'footerElement',
    value: function footerElement() {}
  }, {
    key: 'socketParameters',
    value: function socketParameters(uri) {
      var parsed = url.parse(uri);
      parsed.port = Number(parsed.port);
      parsed.host = parsed.hostname;
      return parsed;
    }
  }]);

  return Connection;
}(EventEmitter);

// Overrirde


Connection.prototype.NS = '';
Connection.prototype.Socket = null;
Connection.prototype.Parser = null;

module.exports = Connection;
module.exports.getHostname = getHostname;
module.exports.XMPPError = XMPPError;
module.exports.StreamError = StreamError;

},{"@xmpp/events":18,"@xmpp/jid":24,"@xmpp/xml":43,"url":1}],18:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var timeout = require('./lib/timeout');
var delay = require('./lib/delay');
var TimeoutError = require('./lib/TimeoutError');
var promise = require('./lib/promise');
var _EventEmitter = require('./lib/EventEmitter');

exports = module.exports = function (_EventEmitter2) {
  _inherits(EventEmitter, _EventEmitter2);

  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    return _possibleConstructorReturn(this, (EventEmitter.__proto__ || Object.getPrototypeOf(EventEmitter)).apply(this, arguments));
  }

  return EventEmitter;
}(_EventEmitter);
exports.EventEmitter = _EventEmitter;
exports.timeout = timeout;
exports.delay = delay;
exports.TimeoutError = TimeoutError;
exports.promise = promise;

},{"./lib/EventEmitter":19,"./lib/TimeoutError":20,"./lib/delay":21,"./lib/promise":22,"./lib/timeout":23}],19:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _EventEmitter = require('events');
var promiseEvent = require('./promise');

var EventEmitter = function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    this._emitter = new _EventEmitter();
    this._handlers = Object.create(null);
  }

  _createClass(EventEmitter, [{
    key: 'promise',
    value: function promise() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return promiseEvent.apply(undefined, [this].concat(args));
    }
  }, {
    key: 'handle',
    value: function handle(event, handler) {
      this._handlers[event] = handler;
    }
  }, {
    key: 'delegate',
    value: function delegate(event) {
      var handler = this._handlers[event];
      if (!handler) {
        throw new Error(event + ' has no handler attached.');
      }

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var promise = handler.apply(undefined, args);
      if (!(promise instanceof Promise)) {
        throw new TypeError(event + ' handler must return a promise.');
      }
      return promise;
    }
  }, {
    key: 'isHandled',
    value: function isHandled(event) {
      return Boolean(this._handlers[event]);
    }
  }]);

  return EventEmitter;
}();

;['on', 'addListener', 'removeListener', 'once', 'emit', 'listenerCount'].forEach(function (name) {
  EventEmitter.prototype[name] = function () {
    var _emitter;

    (_emitter = this._emitter)[name].apply(_emitter, arguments);
  };
});

module.exports = EventEmitter;

},{"./promise":22,"events":2}],20:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

module.exports = function (_Error) {
  _inherits(TimeoutError, _Error);

  function TimeoutError(message) {
    _classCallCheck(this, TimeoutError);

    var _this = _possibleConstructorReturn(this, (TimeoutError.__proto__ || Object.getPrototypeOf(TimeoutError)).call(this, message));

    _this.name = 'TimeoutError';
    return _this;
  }

  return TimeoutError;
}(Error);

},{}],21:[function(require,module,exports){
'use strict';

module.exports = function delay(timeout) {
  return new Promise(function (resolve) {
    setTimeout(resolve, timeout);
  });
};

},{}],22:[function(require,module,exports){
'use strict';

module.exports = function promise(EE, event) {
  var rejectEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'error';

  return new Promise(function (resolve, reject) {
    var cleanup = function cleanup() {
      EE.removeListener(event, onEvent);
      EE.removeListener(rejectEvent, onError);
    };
    function onError(reason) {
      reject(reason);
      cleanup();
    }
    function onEvent(value) {
      resolve(value);
      cleanup();
    }
    EE.once(event, onEvent);
    if (rejectEvent) {
      EE.once(rejectEvent, onError);
    }
  });
};

},{}],23:[function(require,module,exports){
'use strict';

var TimeoutError = require('./TimeoutError');
var delay = require('./delay');

module.exports = function timeout(promise, ms) {
  return Promise.race([promise, delay(ms).then(function () {
    throw new TimeoutError();
  })]);
};

},{"./TimeoutError":20,"./delay":21}],24:[function(require,module,exports){
'use strict';

var JID = require('./lib/JID');
var escaping = require('./lib/escaping');
var parse = require('./lib/parse');

function jid() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (!args[1] && !args[2]) {
    return parse.apply(undefined, args);
  }
  return new (Function.prototype.bind.apply(JID, [null].concat(args)))();
}

exports = module.exports = jid.bind();
exports.jid = jid;
exports.JID = JID;
exports.equal = function (a, b) {
  return a.equals(b);
};
exports.detectEscape = escaping.detect;
exports.escapeLocal = escaping.escape;
exports.unescapeLocal = escaping.unescape;
exports.parse = parse;

},{"./lib/JID":25,"./lib/escaping":26,"./lib/parse":27}],25:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var escaping = require('./escaping');

/**
 * JID implements
 * - XMPP addresses according to RFC6122
 * - XEP-0106: JID Escaping
 *
 * @see http://tools.ietf.org/html/rfc6122#section-2
 * @see http://xmpp.org/extensions/xep-0106.html
 */

var JID = function () {
  function JID(local, domain, resource) {
    _classCallCheck(this, JID);

    if (typeof domain !== 'string' || !domain) {
      throw new TypeError('Invalid domain.');
    }
    this.setDomain(domain);
    this.setLocal(typeof local === 'string' ? local : '');
    this.setResource(typeof resource === 'string' ? resource : '');
  }

  _createClass(JID, [{
    key: Symbol.toPrimitive,
    value: function value(hint) {
      if (hint === 'number') {
        return NaN;
      }
      return this.toString();
    }
  }, {
    key: 'toString',
    value: function toString(unescape) {
      var s = this._domain;
      if (this._local) {
        s = this.getLocal(unescape) + '@' + s;
      }
      if (this._resource) {
        s = s + '/' + this._resource;
      }
      return s;
    }

    /**
     * Convenience method to distinguish users
     * */

  }, {
    key: 'bare',
    value: function bare() {
      if (this._resource) {
        return new JID(this._local, this._domain, null);
      }
      return this;
    }

    /**
       * Comparison function
       * */

  }, {
    key: 'equals',
    value: function equals(other) {
      return this._local === other._local && this._domain === other._domain && this._resource === other._resource;
    }

    /**
     * http://xmpp.org/rfcs/rfc6122.html#addressing-localpart
     * */

  }, {
    key: 'setLocal',
    value: function setLocal(local, escape) {
      escape = escape || escaping.detect(local);

      if (escape) {
        local = escaping.escape(local);
      }

      this._local = local && local.toLowerCase();
      return this;
    }
  }, {
    key: 'getLocal',
    value: function getLocal(unescape) {
      unescape = unescape || false;
      var local = null;

      if (unescape) {
        local = escaping.unescape(this._local);
      } else {
        local = this._local;
      }

      return local;
    }

    /**
     * http://xmpp.org/rfcs/rfc6122.html#addressing-domain
     */

  }, {
    key: 'setDomain',
    value: function setDomain(domain) {
      this._domain = domain.toLowerCase();
      return this;
    }
  }, {
    key: 'getDomain',
    value: function getDomain() {
      return this._domain;
    }

    /**
     * http://xmpp.org/rfcs/rfc6122.html#addressing-resourcepart
     */

  }, {
    key: 'setResource',
    value: function setResource(resource) {
      this._resource = resource;
      return this;
    }
  }, {
    key: 'getResource',
    value: function getResource() {
      return this._resource;
    }
  }]);

  return JID;
}();

Object.defineProperty(JID.prototype, 'local', {
  get: JID.prototype.getLocal,
  set: JID.prototype.setLocal
});

Object.defineProperty(JID.prototype, 'domain', {
  get: JID.prototype.getDomain,
  set: JID.prototype.setDomain
});

Object.defineProperty(JID.prototype, 'resource', {
  get: JID.prototype.getResource,
  set: JID.prototype.setResource
});

module.exports = JID;

},{"./escaping":26}],26:[function(require,module,exports){
'use strict';

module.exports.detect = function (local) {
  if (!local) {
    return false;
  }

  // Remove all escaped sequences
  var tmp = local.replace(/\\20/g, '').replace(/\\22/g, '').replace(/\\26/g, '').replace(/\\27/g, '').replace(/\\2f/g, '').replace(/\\3a/g, '').replace(/\\3c/g, '').replace(/\\3e/g, '').replace(/\\40/g, '').replace(/\\5c/g, '');

  // Detect if we have unescaped sequences
  var search = tmp.search(/\\| |"|&|'|\/|:|<|>|@/g);
  if (search === -1) {
    return false;
  }
  return true;
};

/**
 * Escape the local part of a JID.
 *
 * @see http://xmpp.org/extensions/xep-0106.html
 * @param String local local part of a jid
 * @return An escaped local part
 */
module.exports.escape = function (local) {
  if (local === null) {
    return null;
  }

  return local.replace(/^\s+|\s+$/g, '').replace(/\\/g, '\\5c').replace(/ /g, '\\20').replace(/"/g, '\\22').replace(/&/g, '\\26').replace(/'/g, '\\27').replace(/\//g, '\\2f').replace(/:/g, '\\3a').replace(/</g, '\\3c').replace(/>/g, '\\3e').replace(/@/g, '\\40').replace(/\3a/g, '\x05c3a');
};

/**
 * Unescape a local part of a JID.
 *
 * @see http://xmpp.org/extensions/xep-0106.html
 * @param String local local part of a jid
 * @return unescaped local part
 */
module.exports.unescape = function (local) {
  if (local === null) {
    return null;
  }

  return local.replace(/\\20/g, ' ').replace(/\\22/g, '"').replace(/\\26/g, '&').replace(/\\27/g, "'").replace(/\\2f/g, '/').replace(/\\3a/g, ':').replace(/\\3c/g, '<').replace(/\\3e/g, '>').replace(/\\40/g, '@').replace(/\\5c/g, '\\');
};

},{}],27:[function(require,module,exports){
'use strict';

var JID = require('../lib/JID');

module.exports = function parse(s) {
  var local = void 0;
  var resource = void 0;

  var resourceStart = s.indexOf('/');
  if (resourceStart !== -1) {
    resource = s.substr(resourceStart + 1);
    s = s.substr(0, resourceStart);
  }

  var atStart = s.indexOf('@');
  if (atStart !== -1) {
    local = s.substr(0, atStart);
    s = s.substr(atStart + 1);
  }

  return new JID(local, s, resource);
};

},{"../lib/JID":25}],28:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Plugin = require('./lib/Plugin');
var jid = require('@xmpp/jid');
var xml = require('@xmpp/xml');

function plugin(name, props) {
  var dependencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  var Plugin = function (_Plugin2) {
    _inherits(Plugin, _Plugin2);

    function Plugin() {
      _classCallCheck(this, Plugin);

      return _possibleConstructorReturn(this, (Plugin.__proto__ || Object.getPrototypeOf(Plugin)).apply(this, arguments));
    }

    return Plugin;
  }(_Plugin);

  Object.assign(Plugin.prototype, props);

  return {
    name: name,
    plugin: function plugin(entity) {
      var p = new Plugin();
      p.attach(entity);

      var plugins = {};
      dependencies.forEach(function (dep) {
        plugins[dep.name] = entity.plugin(dep);
      });
      p.plugins = plugins;

      return p;
    },
    unplug: function unplug() {
      // FIXME
    }
  };
}

module.exports = plugin.bind(undefined);
module.exports.plugin = plugin;
module.exports.Plugin = _Plugin;
module.exports.jid = jid;
module.exports.xml = xml;

},{"./lib/Plugin":29,"@xmpp/jid":24,"@xmpp/xml":43}],29:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = require('@xmpp/events');

var Plugin = function (_EventEmitter) {
  _inherits(Plugin, _EventEmitter);

  function Plugin() {
    _classCallCheck(this, Plugin);

    return _possibleConstructorReturn(this, (Plugin.__proto__ || Object.getPrototypeOf(Plugin)).apply(this, arguments));
  }

  _createClass(Plugin, [{
    key: 'attach',
    value: function attach(entity) {
      this.entity = entity;
    }
  }, {
    key: 'detach',
    value: function detach() {
      delete this.entity;
    }

    // Override

  }, {
    key: 'start',
    value: function start() {}
  }, {
    key: 'stop',
    value: function stop() {}
  }]);

  return Plugin;
}(EventEmitter);

module.exports = Plugin;

},{"@xmpp/events":18}],30:[function(require,module,exports){
'use strict';

var _require = require('@xmpp/plugin'),
    plugin = _require.plugin,
    xml = _require.xml;

var streamfeatures = require('../stream-features');
var iqCaller = require('../iq-caller');

/*
 * References
 * https://xmpp.org/rfcs/rfc6120.html#bind
 */

var NS = 'urn:ietf:params:xml:ns:xmpp-bind';

function makeBindElement(resource) {
  return xml('bind', { xmlns: NS }, resource && xml('resource', {}, resource));
}

function match(features) {
  return features.getChild('bind', NS);
}

module.exports = plugin('bind', {
  start: function start() {
    var _this = this;

    var streamFeature = {
      name: 'bind',
      priority: 2500,
      match: match,
      run: function run() {
        return _this.handleFeature();
      }
    };
    this.plugins['stream-features'].add(streamFeature);
  },
  bind: function bind(resource) {
    var _this2 = this;

    this.entity._status('binding');
    return this.plugins['iq-caller'].set(makeBindElement(resource)).then(function (result) {
      _this2.entity._jid(result.getChildText('jid'));
      _this2.entity._status('bound');
    });
  },
  handleFeature: function handleFeature() {
    var _this3 = this;

    var entity = this.entity;

    entity._status('bind');
    return entity.isHandled('bind') ? entity.delegate('bind', function (resource) {
      return _this3.bind(resource);
    }) : this.bind();
  }
}, [streamfeatures, iqCaller]);

},{"../iq-caller":31,"../stream-features":38,"@xmpp/plugin":28}],31:[function(require,module,exports){
'use strict';

var _require = require('@xmpp/plugin'),
    plugin = _require.plugin,
    xml = _require.xml;

module.exports = plugin('iq-caller', {
  start: function start() {
    var _this = this;

    this.handlers = new Map();
    this.handler = function (stanza) {
      if (!_this.match(stanza)) {
        return;
      }

      var id = stanza.attrs.id;


      var handler = _this.handlers.get(id);
      if (!handler) {
        return;
      }

      if (stanza.attrs.type === 'error') {
        handler[1](stanza.getChild('error'));
      } else {
        handler[0](stanza.children[0]);
      }
      _this.handlers.delete(id);
    };
    this.entity.on('element', this.handler);
  },
  stop: function stop() {
    this.entity.removeListener('element', this.handler);
  },
  id: function id() {
    var id = void 0;
    while (!id) {
      id = Math.random().toString(36).substr(2, 12);
    }
    return id;
  },
  match: function match(stanza) {
    return stanza.name === 'iq' && (stanza.attrs.type === 'error' || stanza.attrs.type === 'result');
  },
  get: function get(el) {
    var iq = xml('iq', { type: 'get' });
    iq.append(el);

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return this.request.apply(this, [iq].concat(args));
  },
  set: function set(el) {
    var iq = xml('iq', { type: 'set' });
    iq.append(el);

    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return this.request.apply(this, [iq].concat(args));
  },
  request: function request(stanza, to) {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      if (to && typeof to === 'string' && !stanza.attrs.to) {
        stanza.attrs.to = to;
      }
      if (!stanza.attrs.id) {
        stanza.attrs.id = _this2.id();
      }

      _this2.handlers.set(stanza.attrs.id, [resolve, reject]);

      _this2.entity.send(stanza);
    });
  }
});

},{"@xmpp/plugin":28}],32:[function(require,module,exports){
'use strict';

var plugin = require('@xmpp/plugin');

module.exports = plugin('reconnect', {
  delay: 1000,

  reconnect: function reconnect() {
    var _this = this;

    var entity = this.entity;

    this.emit('reconnecting');
    this._timeout = setTimeout(function () {
      if (entity.status === 'offline') {
        return;
      }
      // Allow calling start() even though status is not offline
      // reset status property right after
      var status = entity.status;

      entity.status = 'offline';

      entity.start(entity.startOptions).then(function () {
        _this.emit('reconnected');
      }).catch(function () {
        return _this.reconnect();
      }).catch(function (err) {
        _this.emit('error', err);
      });
      entity.status = status;
    }, this.delay);
  },
  stopped: function stopped() {
    var entity = this.entity,
        listeners = this.listeners,
        _timeout = this._timeout;

    entity.removeListener('disconnect', listeners.disconnect);
    clearTimeout(_timeout);
  },
  start: function start() {
    var _this2 = this;

    var listeners = {};
    listeners.disconnect = function () {
      _this2.reconnect();
    };
    listeners.online = function () {
      _this2.entity.on('disconnect', listeners.disconnect);
    };
    this.listeners = listeners;
    this.entity.once('online', listeners.online);
  },
  stop: function stop() {
    this.stopped();
    this.entity.removeListener('online', this.listeners.online);
  }
});

},{"@xmpp/plugin":28}],33:[function(require,module,exports){
'use strict';

var mech = require('sasl-anonymous');
var sasl = require('../sasl');

module.exports.name = 'sasl-anonymous';
module.exports.plugin = function plugin(entity) {
  var SASL = entity.plugin(sasl);
  SASL.use(mech);
  return {
    entity: entity
  };
};

},{"../sasl":35,"sasl-anonymous":10}],34:[function(require,module,exports){
'use strict';

var mech = require('sasl-plain');
var sasl = require('../sasl');

module.exports.name = 'sasl-plain';
module.exports.plugin = function plugin(entity) {
  var SASL = entity.plugin(sasl);
  SASL.use(mech);
  return {
    entity: entity
  };
};

},{"../sasl":35,"sasl-plain":12}],35:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require = require('./lib/b64'),
    encode = _require.encode,
    decode = _require.decode;

var plugin = require('@xmpp/plugin');
var xml = require('@xmpp/xml');
var streamFeatures = require('../stream-features');

var _require2 = require('@xmpp/connection'),
    XMPPError = _require2.XMPPError;

var SASLFactory = require('saslmechanisms');

var NS = 'urn:ietf:params:xml:ns:xmpp-sasl';

var SASLError = function (_XMPPError) {
  _inherits(SASLError, _XMPPError);

  function SASLError() {
    var _ref;

    _classCallCheck(this, SASLError);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = SASLError.__proto__ || Object.getPrototypeOf(SASLError)).call.apply(_ref, [this].concat(args)));

    _this.name = 'SASLError';
    return _this;
  }

  return SASLError;
}(XMPPError);

function match(features) {
  return features.getChild('mechanisms', NS);
}

function getMechanismNames(features) {
  return features.getChild('mechanisms', NS).children.map(function (el) {
    return el.text();
  });
}

module.exports = plugin('sasl', {
  start: function start() {
    var _this2 = this;

    this.SASL = new SASLFactory();
    this.streamFeature = {
      name: 'sasl',
      priority: 1000,
      match: match,
      restart: true,
      run: function run(entity, features) {
        return _this2.gotFeatures(features);
      }
    };
    this.plugins['stream-features'].add(this.streamFeature);
  },
  stop: function stop() {
    delete this.SASL;
    this.plugins['stream-features'].remove(this.streamFeature);
    delete this.streamFeature;
    delete this.mech;
  },
  use: function use() {
    var _SASL;

    (_SASL = this.SASL).use.apply(_SASL, arguments);
  },
  gotFeatures: function gotFeatures(features) {
    var _this3 = this;

    var offered = getMechanismNames(features);
    var usable = this.getUsableMechanisms(offered);
    // FIXME const available = this.getAvailableMechanisms()

    return Promise.resolve(this.getMechanism(usable)).then(function (mech) {
      _this3.mech = mech;
      return _this3.handleMechanism(mech, features);
    });
  },
  handleMechanism: function handleMechanism(mech, features) {
    var _this4 = this;

    this.entity._status('authenticate');

    if (mech === 'ANONYMOUS') {
      return this.authenticate(mech, {}, features);
    }

    return this.entity.delegate('authenticate', function (username, password) {
      return _this4.authenticate(mech, { username: username, password: password }, features);
    }, mech);
  },
  getAvailableMechanisms: function getAvailableMechanisms() {
    return this.SASL._mechs.map(function (_ref2) {
      var name = _ref2.name;
      return name;
    });
  },
  getUsableMechanisms: function getUsableMechanisms(mechs) {
    var supported = this.getAvailableMechanisms();
    return mechs.filter(function (mech) {
      return supported.indexOf(mech) > -1;
    });
  },
  getMechanism: function getMechanism(usable) {
    return usable[0]; // FIXME prefer SHA-1, ... maybe order usable, available, ... by preferred?
  },
  findMechanism: function findMechanism(name) {
    return this.SASL.create([name]);
  },
  authenticate: function authenticate(mechname, credentials) {
    var _this5 = this;

    var mech = this.findMechanism(mechname);
    if (!mech) {
      return Promise.reject(new Error('no compatible mechanism'));
    }

    var domain = this.entity.options.domain;

    var creds = Object.assign({
      username: null,
      password: null,
      server: domain,
      host: domain,
      realm: domain,
      serviceType: 'xmpp',
      serviceName: domain
    }, credentials);

    this.entity._status('authenticating');

    return new Promise(function (resolve, reject) {
      var handler = function handler(element) {
        if (element.attrs.xmlns !== NS) {
          return;
        }

        if (element.name === 'challenge') {
          mech.challenge(decode(element.text()));
          var resp = mech.response(creds);
          _this5.entity.send(xml('response', { xmlns: NS, mechanism: mech.name }, typeof resp === 'string' ? encode(resp) : ''));
          return;
        }

        if (element.name === 'failure') {
          reject(new SASLError(element.children[0].name, element.getChildText('text') || '', element));
        } else if (element.name === 'success') {
          resolve();
          _this5.entity._status('authenticated');
        }

        _this5.entity.removeListener('nonza', handler);
      };
      _this5.entity.on('nonza', handler);

      if (mech.clientFirst) {
        _this5.entity.send(xml('auth', { xmlns: NS, mechanism: mech.name }, encode(mech.response(creds))));
      }
    });
  }
}, [streamFeatures]);

},{"../stream-features":38,"./lib/b64":36,"@xmpp/connection":17,"@xmpp/plugin":28,"@xmpp/xml":43,"saslmechanisms":14}],36:[function(require,module,exports){
(function (global,Buffer){
'use strict';

module.exports.encode = function encode(string) {
  if (!global.Buffer) {
    return global.btoa(string);
  }
  return Buffer.from(string, 'utf8').toString('base64');
};

module.exports.decode = function decode(string) {
  if (!global.Buffer) {
    return global.atob(string);
  }
  return Buffer.from(string, 'base64').toString('utf8');
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"buffer":1}],37:[function(require,module,exports){
'use strict';

var _require = require('@xmpp/plugin'),
    plugin = _require.plugin,
    xml = _require.xml;

var streamfeatures = require('../stream-features');
var iqCaller = require('../iq-caller');

var NS = 'urn:ietf:params:xml:ns:xmpp-session';

function match(features) {
  var feature = features.getChild('session', NS);
  return Boolean(feature) && !feature.getChild('optional');
}

module.exports = plugin('session-establishment', {
  start: function start() {
    var _this = this;

    var streamFeature = {
      name: 'session-establishment',
      priority: 2000,
      match: match,
      run: function run() {
        return _this.establishSession();
      }
    };
    this.plugins['stream-features'].add(streamFeature);
  },
  establishSession: function establishSession() {
    return this.entity.plugins['iq-caller'].set(xml('session', 'urn:ietf:params:xml:ns:xmpp-session'));
  }
}, [streamfeatures, iqCaller]);
module.exports.match = match;

},{"../iq-caller":31,"../stream-features":38,"@xmpp/plugin":28}],38:[function(require,module,exports){
'use strict';

/**
 * References
 * https://xmpp.org/rfcs/rfc6120.html#streams-negotiation Stream Negotiation
 * https://xmpp.org/extensions/xep-0170.html XEP-0170: Recommended Order of Stream Feature Negotiation
 * https://xmpp.org/registrar/stream-features.html XML Stream Features
 */

var plugin = require('@xmpp/plugin');

module.exports = plugin('stream-features', {
  start: function start() {
    var _this = this;

    this.features = [];

    var entity = this.entity;

    this.handler = function (el) {
      if (el.name !== 'stream:features') {
        return;
      }

      var streamFeatures = _this.selectFeatures(el);
      if (streamFeatures.length === 0) {
        return;
      }

      function iterate(c) {
        var feature = streamFeatures[c];
        return feature.run(entity, el).then(function () {
          if (feature.restart) {
            return entity.restart();
          } else if (c === streamFeatures.length - 1) {
            if (entity.jid) entity._status('online', entity.jid);
          } else {
            iterate(c + 1);
          }
        }).catch(function (err) {
          return entity.emit('error', err);
        });
      }

      return iterate(0);
    };

    entity.on('nonza', this.handler);
  },
  stop: function stop() {
    delete this.features;
    this.entity.off('nonza', this.handler);
    delete this.handler;
  },
  selectFeatures: function selectFeatures(el) {
    var _this2 = this;

    return this.features.filter(function (f) {
      return f.match(el, _this2.entity) && typeof f.priority === 'number';
    }).sort(function (a, b) {
      return a.priority < b.priority;
    });
  },
  add: function add(_ref) {
    var name = _ref.name,
        priority = _ref.priority,
        run = _ref.run,
        match = _ref.match,
        restart = _ref.restart;

    this.features.push({ name: name, priority: priority, run: run, match: match, restart: restart });
  }
});

},{"@xmpp/plugin":28}],39:[function(require,module,exports){
'use strict';

var ConnectionWebSocket = require('./lib/Connection');

module.exports.name = 'websocket';
module.exports.plugin = function plugin(entity) {
  entity.transports.push(ConnectionWebSocket);
  return {
    entity: entity
  };
};

},{"./lib/Connection":40}],40:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Socket = require('./Socket');
var Connection = require('@xmpp/connection');
var xml = require('@xmpp/xml');
var FramedParser = require('./FramedParser');

var NS_FRAMING = 'urn:ietf:params:xml:ns:xmpp-framing';

/* References
 * WebSocket protocol https://tools.ietf.org/html/rfc6455
 * WebSocket Web API https://html.spec.whatwg.org/multipage/comms.html#network
 * XMPP over WebSocket https://tools.ietf.org/html/rfc7395
*/

var ConnectionWebSocket = function (_Connection) {
  _inherits(ConnectionWebSocket, _Connection);

  function ConnectionWebSocket() {
    _classCallCheck(this, ConnectionWebSocket);

    return _possibleConstructorReturn(this, (ConnectionWebSocket.__proto__ || Object.getPrototypeOf(ConnectionWebSocket)).apply(this, arguments));
  }

  _createClass(ConnectionWebSocket, [{
    key: 'footerElement',

    // https://tools.ietf.org/html/rfc7395#section-3.6
    value: function footerElement() {
      return new xml.Element('close', {
        xmlns: NS_FRAMING
      });
    }

    // https://tools.ietf.org/html/rfc7395#section-3.4

  }, {
    key: 'headerElement',
    value: function headerElement() {
      var el = _get(ConnectionWebSocket.prototype.__proto__ || Object.getPrototypeOf(ConnectionWebSocket.prototype), 'headerElement', this).call(this);
      el.name = 'open';
      el.attrs.xmlns = NS_FRAMING;
      return el;
    }
  }, {
    key: 'socketParameters',
    value: function socketParameters(uri) {
      return uri.match(/^wss?:\/\//) ? uri : undefined;
    }
  }]);

  return ConnectionWebSocket;
}(Connection);

ConnectionWebSocket.prototype.Socket = Socket;
ConnectionWebSocket.prototype.NS = 'jabber:client';
ConnectionWebSocket.prototype.Parser = FramedParser;

module.exports = ConnectionWebSocket;

},{"./FramedParser":41,"./Socket":42,"@xmpp/connection":17,"@xmpp/xml":43}],41:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require = require('@xmpp/xml'),
    Parser = _require.Parser;

module.exports = function (_Parser) {
  _inherits(FramedParser, _Parser);

  function FramedParser() {
    _classCallCheck(this, FramedParser);

    return _possibleConstructorReturn(this, (FramedParser.__proto__ || Object.getPrototypeOf(FramedParser)).apply(this, arguments));
  }

  _createClass(FramedParser, [{
    key: 'onStartElement',
    value: function onStartElement() {}
  }, {
    key: 'onEndElement',
    value: function onEndElement(element, length) {
      if (length === 1) {
        if (element.is('open', 'urn:ietf:params:xml:ns:xmpp-framing')) {
          this.emit('start', element);
        } else if (element.is('close', 'urn:ietf:params:xml:ns:xmpp-framing')) {
          this.emit('end', element);
        } else {
          this.emit('element', element);
        }
      }
    }
  }]);

  return FramedParser;
}(Parser);

},{"@xmpp/xml":43}],42:[function(require,module,exports){
(function (global){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WS = require('ws');
var WebSocket = global.WebSocket || WS;
var EventEmitter = require('events');

var Socket = function (_EventEmitter) {
  _inherits(Socket, _EventEmitter);

  function Socket() {
    _classCallCheck(this, Socket);

    var _this = _possibleConstructorReturn(this, (Socket.__proto__ || Object.getPrototypeOf(Socket)).call(this));

    _this.listeners = Object.create(null);
    return _this;
  }

  _createClass(Socket, [{
    key: 'connect',
    value: function connect(url, fn) {
      this.url = url;
      this._attachSocket(new WebSocket(url, ['xmpp']), fn);
    }
  }, {
    key: '_attachSocket',
    value: function _attachSocket(socket, fn) {
      var _this2 = this;

      var sock = this.socket = socket;
      var listeners = this.listeners;

      listeners.open = function () {
        _this2.emit('connect');
        if (fn) {
          fn();
        }
      };
      listeners.message = function (_ref) {
        var data = _ref.data;
        return _this2.emit('data', data);
      };
      listeners.error = function (err) {
        _this2.emit('error', err instanceof Error ? err : new Error('connection error ' + _this2.url));
      };
      listeners.close = function (_ref2) {
        var code = _ref2.code,
            reason = _ref2.reason;

        _this2._detachSocket();
        _this2.emit('close', { code: code, reason: reason });
      };

      sock.addEventListener('open', listeners.open);
      sock.addEventListener('message', listeners.message);
      sock.addEventListener('error', listeners.error);
      sock.addEventListener('close', listeners.close);
    }
  }, {
    key: '_detachSocket',
    value: function _detachSocket() {
      delete this.url;
      var socket = this.socket,
          listeners = this.listeners;

      Object.getOwnPropertyNames(listeners).forEach(function (k) {
        socket.removeEventListener(k, listeners[k]);
        delete listeners[k];
      });
      delete this.socket;
    }
  }, {
    key: 'end',
    value: function end() {
      this.socket.close();
    }
  }, {
    key: 'write',
    value: function write(data, fn) {
      if (WebSocket === WS) {
        this.socket.send(data, fn);
      } else {
        this.socket.send(data);
        fn();
      }
    }
  }]);

  return Socket;
}(EventEmitter);

module.exports = Socket;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"events":2,"ws":1}],43:[function(require,module,exports){
'use strict';

var x = require('./lib/x');
var Element = require('./lib/Element');
var Parser = require('./lib/Parser');

var _require = require('ltx/lib/escape'),
    escapeXML = _require.escapeXML,
    unescapeXML = _require.unescapeXML,
    escapeXMLText = _require.escapeXMLText,
    unescapeXMLText = _require.unescapeXMLText;

function xml() {
  return x.apply(undefined, arguments);
}

exports = module.exports = xml;

Object.assign(exports, {
  x: x,
  Element: Element,
  Parser: Parser,
  escapeXML: escapeXML,
  unescapeXML: unescapeXML,
  escapeXMLText: escapeXMLText,
  unescapeXMLText: unescapeXMLText
});

},{"./lib/Element":44,"./lib/Parser":45,"./lib/x":46,"ltx/lib/escape":7}],44:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Element = require('ltx/lib/Element');

var Element = function (_Element2) {
  _inherits(Element, _Element2);

  function Element() {
    _classCallCheck(this, Element);

    return _possibleConstructorReturn(this, (Element.__proto__ || Object.getPrototypeOf(Element)).apply(this, arguments));
  }

  _createClass(Element, [{
    key: 'append',
    value: function append(nodes) {
      var _this2 = this;

      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes.forEach(function (node) {
        _this2.children.push(node);
        if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
          node.parent = _this2;
        }
      });
    }
  }, {
    key: 'prepend',
    value: function prepend(nodes) {
      var _this3 = this;

      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes.forEach(function (node) {
        _this3.children.unshift(node);
        if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
          node.parent = _this3;
        }
      });
    }
  }]);

  return Element;
}(_Element);

module.exports = Element;

},{"ltx/lib/Element":4}],45:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LtxParser = require('ltx/lib/parsers/ltx');
var Element = require('./Element');
var EventEmitter = require('events');

var XMLError = function (_Error) {
  _inherits(XMLError, _Error);

  function XMLError() {
    var _ref;

    _classCallCheck(this, XMLError);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = XMLError.__proto__ || Object.getPrototypeOf(XMLError)).call.apply(_ref, [this].concat(args)));

    _this.name = 'XMLError';
    return _this;
  }

  return XMLError;
}(Error);

var Parser = function (_EventEmitter) {
  _inherits(Parser, _EventEmitter);

  function Parser() {
    _classCallCheck(this, Parser);

    var _this2 = _possibleConstructorReturn(this, (Parser.__proto__ || Object.getPrototypeOf(Parser)).call(this));

    var parser = new LtxParser();
    var stack = [];
    var cursor = void 0;

    parser.on('startElement', function (name, attrs) {
      var child = new Element(name, attrs);
      if (cursor) {
        cursor.append(child);
      }
      _this2.onStartElement(child, cursor);
      _this2.emit('startElement', child);
      stack.push(cursor);
      cursor = child;
    });
    parser.on('endElement', function (name) {
      if (name === cursor.name) {
        _this2.onEndElement(cursor, stack.length);
        _this2.emit('endElement', cursor);
        cursor = stack.pop();
      } else {
        // <foo></bar>
        _this2.emit('error', new XMLError(cursor.name + ' must be closed.'));
      }
    });

    parser.on('text', function (str) {
      _this2.onText(str, cursor);
    });
    _this2.parser = parser;
    return _this2;
  }

  _createClass(Parser, [{
    key: 'onStartElement',
    value: function onStartElement(element, cursor) {
      if (!cursor) {
        this.emit('start', element);
      }
    }
  }, {
    key: 'onEndElement',
    value: function onEndElement(element, length) {
      if (length === 2) {
        this.emit('element', element);
      } else if (length === 1) {
        this.emit('end', element);
      }
    }
  }, {
    key: 'onText',
    value: function onText(str, element) {
      if (!element) {
        this.emit('error', new XMLError(str + ' must be a child.'));
        return;
      }
      element.t(str);
    }
  }, {
    key: 'write',
    value: function write(data) {
      this.parser.write(data);
    }
  }, {
    key: 'end',
    value: function end(data) {
      if (data) {
        this.parser.write(data);
      }
    }
  }]);

  return Parser;
}(EventEmitter);

Parser.XMLError = XMLError;

module.exports = Parser;

},{"./Element":44,"events":2,"ltx/lib/parsers/ltx":8}],46:[function(require,module,exports){
'use strict';

var Element = require('./Element');

function append(el, child) {
  if (child instanceof Element) {
    el.append(child);
  } else if (Array.isArray(child)) {
    child.forEach(function (c) {
      return append(el, c);
    });
  } else if (child !== null && child !== undefined) {
    el.append(String(child));
  }
}

function x(name, attrs) {
  var el = new Element(name, attrs);

  for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  for (var i = 0; i < children.length; i++) {
    append(el, children[i]);
  }
  return el;
}

module.exports = x;

},{"./Element":44}],47:[function(require,module,exports){
'use strict';

var Client = require('./lib/Client');

var _require = require('@xmpp/client-core'),
    xml = _require.xml,
    jid = _require.jid;

module.exports.Client = Client;
module.exports.xml = xml;
module.exports.jid = jid;

},{"./lib/Client":48,"@xmpp/client-core":15}],48:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ClientCore = require('@xmpp/client-core').Client;
var plugins = require('./plugins');

var Client = function (_ClientCore) {
  _inherits(Client, _ClientCore);

  function Client() {
    var _ref;

    _classCallCheck(this, Client);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = Client.__proto__ || Object.getPrototypeOf(Client)).call.apply(_ref, [this].concat(args)));

    Object.keys(plugins).forEach(function (name) {
      var plugin = plugins[name];
      // Ignore browserify stubs
      if (!plugin.plugin) {
        return;
      }
      _this.plugin(plugin);
    });
    return _this;
  }

  return Client;
}(ClientCore);

module.exports = Client;

},{"./plugins":49,"@xmpp/client-core":15}],49:[function(require,module,exports){
'use strict';

exports['stream-features'] = require('@xmpp/plugins/stream-features');
exports.bind = require('@xmpp/plugins/bind');
exports.sasl = require('@xmpp/plugins/sasl');
exports['sasl-plain'] = require('@xmpp/plugins/sasl-plain');
exports['sasl-anonymous'] = require('@xmpp/plugins/sasl-anonymous');
exports.websocket = require('@xmpp/plugins/websocket');
exports.tcp = require('@xmpp/plugins/tcp');
exports.tls = require('@xmpp/plugins/tls');
exports.reconnect = require('@xmpp/plugins/reconnect');
exports.starttls = require('@xmpp/plugins/starttls');
exports['session-establishment'] = require('@xmpp/plugins/session-establishment');

},{"@xmpp/plugins/bind":30,"@xmpp/plugins/reconnect":32,"@xmpp/plugins/sasl":35,"@xmpp/plugins/sasl-anonymous":33,"@xmpp/plugins/sasl-plain":34,"@xmpp/plugins/session-establishment":37,"@xmpp/plugins/starttls":1,"@xmpp/plugins/stream-features":38,"@xmpp/plugins/tcp":1,"@xmpp/plugins/tls":1,"@xmpp/plugins/websocket":39}]},{},[47])(47)
});
//# sourceMappingURL=xmpp.js.map
